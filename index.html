<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8">
  <!-- Tell IE to use the latest, best version. -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>Cesium Drawing</title>
  <script src="Cesium/Cesium/Cesium.js"></script>
  <script src="js/DynamicProperty.js"></script>
  <script src="js/jquery-3.1.1.min.js"></script>
  <style>
    @import url(Cesium/Cesium/Widgets/widgets.css);
      html, body, #cesiumContainer {
        position: absolute;
        width: 100%;
        bottom: 0px;
        top: 0px;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      .toolbar {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: #ffffff;
      }

      .toolbar > .button {
        cursor: pointer;
        padding: 2px;
      }

      .toolbar > .button:hover {
        background: #eee;
      }


  </style>
</head>
<body>

    <div id="cesiumContainer"></div>

    <div class="toolbar">
      <div id="drawPolyline" class="button">
          <span><img src="img/drawPolyline.png"></img></span>
      </div>
      <div id="drawPolygon" class="button">
          <span><img src="img/drawPolygon.png"></img></span>
      </div>
      <div id="drawExtrudedPolygon" class="button">
          <span><img src="img/drawExtrudedPolygon.png"></img></span>
      </div>
      <div id="drawCircle" class="button">
          <span><img src="img/drawCircle.png"></img></span>
      </div>
    </div>

    <script>

    var viewer = new Cesium.Viewer('cesiumContainer', {
      selectionIndicator : false
    });

    // Disable the default entity double click action.
    viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);

    function createPositionsHandler(entity, positions) {

      var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

      // Adds a point to the positions list.
      handler.lastPointTemporary = false;
      handler.setInputAction(function(movement) {
          var cartesian = viewer.camera.pickEllipsoid(movement.position, viewer.scene.globe.ellipsoid);
          if (cartesian) {
            if (handler.lastPointTemporary)
            {
                positions.pop();
            }
            var index = positions.length;
            positions.push( cartesian );
            handler.lastPointTemporary = false;
          }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      // Replaces the last point in the list with the point under the mouse.
      handler.setInputAction(function(movement) {
        if (movement.endPosition) {
            var cartesian = viewer.camera.pickEllipsoid(movement.endPosition, viewer.scene.globe.ellipsoid);
            if (cartesian) {
              if (handler.lastPointTemporary)
              {
                positions.pop();
              }
              positions.push( cartesian );
              handler.lastPointTemporary = true;
            }
          }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      handler.setInputAction(function(movement) {
          entity.inProgress = false;
          handler.destroy();
      }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

      return handler;
    }


    function drawPolyline() {

      // Create the entity
      var entity = viewer.entities.add({
          name : 'Entity',
          polyline : {
              positions: new DynamicProperty([]),
              width : 2,
              material : Cesium.Color.RED
          }
      });

      entity.inProgress = true;
      createPositionsHandler( entity, entity.polyline.positions._value );
    }

    function drawPolygon() {

      // Create the entity
      var entity = viewer.entities.add({
          name : 'Entity',
          polygon : {
            hierarchy: new DynamicProperty([]),
            material : Cesium.Color.RED
          }
      });

      createPositionsHandler( entity, entity.polygon.hierarchy._value );
    }

    function drawExtrudedPolygon() {

      // Create the entity
      var entity = viewer.entities.add({
          name : 'Entity',
          polygon : {
            hierarchy: new DynamicProperty([]),
            extrudedHeight: 50000,
            perPositionHeight : true,
            material : Cesium.Color.ORANGE.withAlpha(0.5),
            outline : true,
            outlineColor : Cesium.Color.BLACK
        }
      });

      createPositionsHandler( entity, entity.polygon.hierachy._value );
    }

    function drawCircle() {

      var position = Cesium.Cartesian3.fromDegrees(-103.0, 40.0);

      // Create an ellipse.
      // Should really wait for the first click.
      var entity = viewer.entities.add({
        position: new DynamicProperty(position),
        name : 'Entity',
        ellipse : {
            semiMinorAxis : 300000.0,
            semiMajorAxis : 300000.0,
            material : Cesium.Color.GREEN.withAlpha(0.5),
            outline : true,
            outlineColor : Cesium.Color.BLACK
        }
      });

      entity.inProgress = false;
    }

    var draggers = [];
    var currentEntity = null;

    function startEditing( entity ) {
      if (entity.polyline) {
        var positions = entity.polyline.positions._value;
        entity.polyline.positions.isConstant = false;
        for (var i = 0; i < positions.length; i++) {
            var loc = positions[i];
            var dragger = createDragger( loc, function(dragger, position) {
                dragger.positions[dragger.index] = position;
            });
            dragger.index = i;
            dragger.positions = positions;
            draggers.push( dragger );
        }
      }
      else if (entity.polygon) {
        var positions = entity.polygon.hierarchy._value;
        entity.polygon.hierarchy.isConstant = false;
        for (var i = 0; i < positions.length; i++) {
            var loc = positions[i];
            var dragger = createDragger( loc, function(dragger, position) {
                dragger.positions[dragger.index] = position;
            });
            dragger.index = i;
            dragger.positions = positions;
            draggers.push( dragger );
        }
      }
      else if (entity.ellipse) {
        // Create a dragger that just modifies the entities position.
        var dragger = createDragger(entity.position._value, function(dragger, newPosition) {

          var diff = new Cesium.Cartesian3();
          Cesium.Cartesian3.subtract(newPosition, entity.position._value, diff);
          entity.position._value = newPosition;


          var newPos = new Cesium.Cartesian3();
          Cesium.Cartesian3.add(dragger.radiusDragger.position._value, diff, newPos)
          dragger.radiusDragger.position = new Cesium.ConstantProperty(newPos);

        });
        draggers.push( dragger );


        var cep = Cesium.EllipseGeometryLibrary.computeEllipsePositions({
          center: entity.position._value,
          semiMinorAxis: entity.ellipse.semiMinorAxis._value,
          semiMajorAxis: entity.ellipse.semiMajorAxis._value,
          rotation: 0.0,
          granularity: 2.0
        }, true, false);
        var pos = new Cesium.Cartesian3(cep.positions[0], cep.positions[1], cep.positions[2]);
        var radiusDragger = createDragger(pos, function(dragger, newPosition) {
          var radius = Cesium.Cartesian3.distance(entity.position._value, newPosition);
          entity.ellipse.semiMinorAxis = new Cesium.ConstantProperty( radius );
          entity.ellipse.semiMajorAxis = new Cesium.ConstantProperty( radius );
        });
        dragger.radiusDragger = radiusDragger;
        draggers.push( radiusDragger );
      }
    }

    function stopEditing( entity ) {
      // Mark the position properties as being constant since we are done editing.
      // You will see a flash as the geometry rebuilds, but rendering performance of the static geometries will
      // be faster.
      if (entity.polyline) {
        entity.polyline.positions.isConstant = true;
      }
      else if (entity.polygon) {
        entity.polygon.hierarchy.isConstant = true;
      }

      // Get rid of all the draggers.
      for (var i = 0; i < draggers.length; i++) {
        viewer.entities.remove( draggers[i]);
      }
      draggers = [];
    }

    function createDragger(position, onDrag) {
       var dragger = viewer.entities.add({
          position : position,
          billboard :{
              image : "img/dragIcon.png"
          }
      });
      dragger._isDragger = true;
      dragger.onDrag = onDrag;
      return dragger;
    }

    var draggerHandler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
    draggerHandler.dragger = null;

    draggerHandler.setInputAction(
        function(click) {
            var pickedObject = viewer.scene.pick(click.position);
            if (Cesium.defined(pickedObject)) {
                var entity = pickedObject.id;
                if (Cesium.defaultValue(entity._isDragger, false)) {
                  entity.billboard.scale = 1.2;
                  draggerHandler.dragger = entity;
                  viewer.scene.screenSpaceCameraController.enableRotate = false;
                }
            }
        },
        Cesium.ScreenSpaceEventType.LEFT_DOWN
    );

    draggerHandler.setInputAction(
        function(movement) {
            if (draggerHandler.dragger) {
              var hit = viewer.camera.pickEllipsoid(movement.endPosition);
                if (hit) {
                  draggerHandler.dragger.position = hit;
                  if (draggerHandler.dragger.onDrag) {
                    draggerHandler.dragger.onDrag(draggerHandler.dragger, hit);
                  }
                }
            }
        },
        Cesium.ScreenSpaceEventType.MOUSE_MOVE
    );

    draggerHandler.setInputAction(
        function() {
            if (draggerHandler.dragger) {
              draggerHandler.dragger.billboard.scale = 1;
              draggerHandler.dragger = null;
              viewer.scene.screenSpaceCameraController.enableRotate = true;
            }
        },
        Cesium.ScreenSpaceEventType.LEFT_UP
    );

    var selectEntityHandler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
    selectEntityHandler.setInputAction(
        function(e) {
            var picked = viewer.scene.pick(e.position);

            var pickedEntity = null;

            if (Cesium.defined(picked)) {
                var id = Cesium.defaultValue(picked.id, picked.primitive.id);
                if (id instanceof Cesium.Entity) {
                    var inProgress = Cesium.defaultValue( id.inProgress, true);
                    if (!inProgress) {
                        pickedEntity = id;
                    }
                }
            }

            if (pickedEntity !== currentEntity) {
              if (currentEntity) {
                stopEditing( currentEntity );
                currentEntity = null;
              }

              currentEntity = pickedEntity;

              if (currentEntity) {
                startEditing(currentEntity);
              }
            }
        },
        Cesium.ScreenSpaceEventType.LEFT_CLICK
    );


    $(function() {
      $("#drawPolyline").click(function() {
        drawPolyline();
      });

      $("#drawPolygon").click(function() {
        drawPolygon();
      });

      $("#drawExtrudedPolygon").click(function() {
        drawExtrudedPolygon();
      });

      $("#drawCircle").click(function() {
        drawCircle();
      });

    });

    </script>

</body>
</html>


